-- @nsURI MM=http://www.eclipse.org/uml2/5.0.0/UML

module cleanup;
create OUT : MM from IN : MM;

rule Model {
	from 
		m : MM!Model
	to 
		m_copy : MM!Model (
			name <- m.name,
			packagedElement <- m.packagedElement
		)
}

rule StateMachine {
  from
    sm : MM!StateMachine
  to
    sm_copy : MM!StateMachine (
      name <- sm.name,
      region <- sm.region
    )
}

helper def: findTargetState(sm : MM!StateMachine) : MM!State =
    sm.region->first().subvertex->select(e | e.oclIsTypeOf(MM!State) and not sm.region->first().transition->exists(t | t.target = e))->first();

--Filtrowanie przejść o takich samych source i target do nowej sekwencji
helper context MM!Region def : filterTrans(tran_in: Sequence(MM!Transition)) : Sequence(MM!Transition) = 
	tran_in->iterate(t; result: Sequence(MM!Transition) = Sequence{} |
	if ((t.source.oclIsUndefined() and t.target.oclIsUndefined()) or result->exists(r | (r.source = t.source and r.target = t.target))) then
		result
	else
		result->append(t)
	endif
);

--Wykonanie rule transition na sekwencji przejść
helper context MM!Region def : performTransition(filtered : Sequence(MM!Transition)) : Sequence(MM!Transition) =
	filtered->iterate(t; result: Sequence(MM!Transition) = Sequence{} |
	if(t.source.oclIsTypeOf(MM!Pseudostate)) then
		if(t.source.kind <> #initial) then
			result->append(thisModule.transition(t)) 
		else 
			result 
		endif
	else
		if(not t.target.oclIsTypeOf(MM!FinalState)) then
			result->append(thisModule.transition(t))
		else
			result
		endif
	endif
);



lazy rule InitialStateCopy {
  from
    ps : MM!Pseudostate (ps.kind = #initial)
  to
    ps_copy : MM!Pseudostate (
      name <- ps.name,
      kind <- ps.kind,
	  container <- ps.container
    )
}



lazy rule FinalStateCopy {
	from 
      s : MM!FinalState
	to 
	  s_copy : MM!FinalState(
	  	name <- s.name,
		container <- s.container
	  )
}

-- Kopiowanie tylko poprawnych stanów (posiada entry i exit)
rule State {
  from
    s : MM!State (s.oclIsTypeOf(MM!State) and (((not s.entry.oclIsUndefined()) and (not s.exit.oclIsUndefined())) or
    	((not MM!Transition.allInstances()->select(tran | tran.source = s).isEmpty()) or (not MM!Transition.allInstances()->select(tran | tran.target = s).isEmpty())))	
    )
  to
    s_copy : MM!State (
      name <- s.name,
      entry <- s.entry,
      exit <- s.exit,
	  container <- s.container
    )
}

rule Region {
  from
    r : MM!Region
  to
    r_copy : MM!Region (
      name <- r.name,
      subvertex <- r.subvertex,
      transition <-  r.performTransition(r.filterTrans(r.transition))
	  )
	do {
		r.debug('Evaluating initial states for');
		if(r.subvertex -> 
				select(sub | sub.oclIsTypeOf(MM!Pseudostate)).debug('subvertices') -> 
					select(sub | sub.kind = #initial).debug('initialStates').isEmpty()) {
			thisModule.initialState(r_copy);
		} else {
			thisModule.InitialStateCopy(r.subvertex -> select(sub | sub.oclIsTypeOf(MM!Pseudostate)) -> 
				select(sub | sub.kind = #initial).first());
		}
		
		if(r.transition -> 
				select(t | t.source = r.subvertex ->
					select(sub | sub.oclIsTypeOf(MM!Pseudostate)) -> 
						select(sub | sub.kind = #initial).first()).isEmpty() and r.transition -> select(t | t.target.oclIsUndefined()).isEmpty()) {
			thisModule.initialStateTransition(r, r_copy);
		} else if (r.transition ->
				select(t | t.source = r.subvertex ->
					select(sub | sub.oclIsTypeOf(MM!Pseudostate)) -> 
						select(sub | sub.kind = #initial).first()).debug('trans from init').size().debug('sze') > 0) {
			thisModule.transition(r.transition -> select(t | t.source = r.subvertex ->
					select(sub | sub.oclIsTypeOf(MM!Pseudostate)) -> 
						select(sub | sub.kind = #initial).first()).debug('copying transition to initial').first());
		}
		
		
		r.debug('Evaluating final states for');
		if(r.subvertex -> 
				select(sub | sub.oclIsTypeOf(MM!FinalState)).debug('finalStates')
					.isEmpty()) {
			thisModule.finalState(r_copy);
		} else {
			thisModule.FinalStateCopy(r.subvertex -> 
				select(sub | sub.oclIsTypeOf(MM!FinalState)).debug('finalStates').first());
		}
		
		if(r.transition -> 
				select(t | r.subvertex -> select(sub | sub.oclIsTypeOf(MM!FinalState)).debug('subvertecises').includes(t.target.debug('t.target'))).isEmpty().debug('condition_1')) {
			thisModule.finalStateTransition(r, r_copy);	
		} else if (r.transition ->
				select(t | t.target = r.subvertex ->
					select(sub | sub.oclIsTypeOf(MM!FinalState)).first()).debug('trans to final').size().debug('sze') > 0) {
			for(trans in r.transition -> select(t | t.target = r.subvertex ->
					select(sub | sub.oclIsTypeOf(MM!FinalState))).debug('copying transitions to final')) {
			thisModule.transition(trans);
					}
			
		}
	}
}

rule initialState(reg : MM!Region) {
	to 
		t : MM!Pseudostate 
		do {
	        t.kind <- #initial;
	        t.container <- reg;
			t.name <- 'start';
			t.debug('created initial state');
		}
}


rule finalState(reg : MM!Region) {
	to
		t : MM!FinalState
		do {
			t.container <- reg;
			t.name <- 'finish';
			t.debug('created final state');
		}
}

rule initialStateTransition(reg : MM!region, reg_copy : MM!region) {
	using {
		state : Sequence(MM!State) = reg.subvertex -> select(s | s.oclIsTypeOf(MM!State));
		candidate_states : Sequence(MM!State) = state -> select(s | reg.transition -> select(t | t.target = s).isEmpty());
		}
	to 
		t : MM!Transition
		do {
			t.name <- 'startTransition';
			t.container <- reg_copy;
			t.source <- reg_copy.subvertex -> select(sub | sub.oclIsTypeOf(MM!Pseudostate)).debug('initialStateTransition:subvertices') -> 
				select(sub | sub.kind = #initial).debug('initialStateTransition:initialStates').first();
			t.target <- if candidate_states.isEmpty() then state.first() else candidate_states.first() endif;
		}
}

rule finalStateTransition(reg : MM!region, reg_copy : MM!region) {
	using {
		state : Sequence(MM!State) = reg.subvertex -> select(s | s.oclIsTypeOf(MM!State) and not reg.transition -> select(t | t.source = s or t.target = s).isEmpty());
		candidate_states : Sequence(MM!State) = state -> select(s | reg.transition -> select(t | t.source = s).isEmpty());
		}
	to 
		t : MM!Transition
		do {
			t.name <- 'finalTransition';
			t.container <- reg_copy;
			t.target <- reg_copy.subvertex -> select(sub | sub.oclIsTypeOf(MM!FinalState)).debug('finalStateTransition:finalStates').first();
			t.source <- if candidate_states.isEmpty() then state.last() else candidate_states.first() endif;
		}
}

lazy rule transition{
	from
		trans_in : MM!Transition 
	to 
		trans_out : MM!Transition (
		name<- trans_in.name,
		source<- trans_in.source,
		target<- trans_in.target,
		container <- trans_in.container
	)
}


helper context MM!Region def: uniqueStates(states: Sequence(MM!State)): Sequence(MM!State) =
  states->iterate(s; result: Sequence(MM!State) = Sequence{} |
    if result->exists(r | r.name = s.name) then
      result
    else
      result->append(s)
    endif
  );


rule Pseudostate {
  from
    ps : MM!Pseudostate (ps.kind <> #initial)
  to
    ps_copy : MM!Pseudostate (
      name <- ps.name,
      kind <- ps.kind
    )
}

rule OpaqueBehavior{
  from 
	b : MM!OpaqueBehavior
  to
  	b_copy : MM!OpaqueBehavior(
  	  name <- b.name
  	)
}


